/* Auto-generated by genmsg_cpp for file /home/mlab/ros/HAWK-basestation/ic2020_vodom/msg/keyframe.msg */
#ifndef IC2020_VODOM_MESSAGE_KEYFRAME_H
#define IC2020_VODOM_MESSAGE_KEYFRAME_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace ic2020_vodom
{
template <class ContainerAllocator>
struct keyframe_ {
  typedef keyframe_<ContainerAllocator> Type;

  keyframe_()
  : keyframe_num(0)
  , rotation()
  , translation()
  , height(0)
  , width(0)
  , im()
  , numberOf3DPoints(0)
  , point_step(0)
  , points()
  , numCorn1(0)
  , corn1()
  , status()
  , numCorn2(0)
  , corn2()
  , numSURF(0)
  , features()
  , descBuffer()
  , surfMatches()
  , imux(0.0)
  , imuy(0.0)
  , imuz(0.0)
  {
  }

  keyframe_(const ContainerAllocator& _alloc)
  : keyframe_num(0)
  , rotation(_alloc)
  , translation(_alloc)
  , height(0)
  , width(0)
  , im(_alloc)
  , numberOf3DPoints(0)
  , point_step(0)
  , points(_alloc)
  , numCorn1(0)
  , corn1(_alloc)
  , status(_alloc)
  , numCorn2(0)
  , corn2(_alloc)
  , numSURF(0)
  , features(_alloc)
  , descBuffer(_alloc)
  , surfMatches(_alloc)
  , imux(0.0)
  , imuy(0.0)
  , imuz(0.0)
  {
  }

  typedef uint32_t _keyframe_num_type;
  uint32_t keyframe_num;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _rotation_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  rotation;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _translation_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  translation;

  typedef uint32_t _height_type;
  uint32_t height;

  typedef uint32_t _width_type;
  uint32_t width;

  typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _im_type;
  std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  im;

  typedef uint32_t _numberOf3DPoints_type;
  uint32_t numberOf3DPoints;

  typedef uint32_t _point_step_type;
  uint32_t point_step;

  typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _points_type;
  std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  points;

  typedef uint32_t _numCorn1_type;
  uint32_t numCorn1;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _corn1_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  corn1;

  typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  _status_type;
  std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other >  status;

  typedef uint32_t _numCorn2_type;
  uint32_t numCorn2;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _corn2_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  corn2;

  typedef uint32_t _numSURF_type;
  uint32_t numSURF;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _features_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  features;

  typedef std::vector<float, typename ContainerAllocator::template rebind<float>::other >  _descBuffer_type;
  std::vector<float, typename ContainerAllocator::template rebind<float>::other >  descBuffer;

  typedef std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  _surfMatches_type;
  std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other >  surfMatches;

  typedef float _imux_type;
  float imux;

  typedef float _imuy_type;
  float imuy;

  typedef float _imuz_type;
  float imuz;


  ROS_DEPRECATED uint32_t get_rotation_size() const { return (uint32_t)rotation.size(); }
  ROS_DEPRECATED void set_rotation_size(uint32_t size) { rotation.resize((size_t)size); }
  ROS_DEPRECATED void get_rotation_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->rotation; }
  ROS_DEPRECATED void set_rotation_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->rotation = vec; }
  ROS_DEPRECATED uint32_t get_translation_size() const { return (uint32_t)translation.size(); }
  ROS_DEPRECATED void set_translation_size(uint32_t size) { translation.resize((size_t)size); }
  ROS_DEPRECATED void get_translation_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->translation; }
  ROS_DEPRECATED void set_translation_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->translation = vec; }
  ROS_DEPRECATED uint32_t get_im_size() const { return (uint32_t)im.size(); }
  ROS_DEPRECATED void set_im_size(uint32_t size) { im.resize((size_t)size); }
  ROS_DEPRECATED void get_im_vec(std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other > & vec) const { vec = this->im; }
  ROS_DEPRECATED void set_im_vec(const std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other > & vec) { this->im = vec; }
  ROS_DEPRECATED uint32_t get_points_size() const { return (uint32_t)points.size(); }
  ROS_DEPRECATED void set_points_size(uint32_t size) { points.resize((size_t)size); }
  ROS_DEPRECATED void get_points_vec(std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other > & vec) const { vec = this->points; }
  ROS_DEPRECATED void set_points_vec(const std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other > & vec) { this->points = vec; }
  ROS_DEPRECATED uint32_t get_corn1_size() const { return (uint32_t)corn1.size(); }
  ROS_DEPRECATED void set_corn1_size(uint32_t size) { corn1.resize((size_t)size); }
  ROS_DEPRECATED void get_corn1_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->corn1; }
  ROS_DEPRECATED void set_corn1_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->corn1 = vec; }
  ROS_DEPRECATED uint32_t get_status_size() const { return (uint32_t)status.size(); }
  ROS_DEPRECATED void set_status_size(uint32_t size) { status.resize((size_t)size); }
  ROS_DEPRECATED void get_status_vec(std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other > & vec) const { vec = this->status; }
  ROS_DEPRECATED void set_status_vec(const std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other > & vec) { this->status = vec; }
  ROS_DEPRECATED uint32_t get_corn2_size() const { return (uint32_t)corn2.size(); }
  ROS_DEPRECATED void set_corn2_size(uint32_t size) { corn2.resize((size_t)size); }
  ROS_DEPRECATED void get_corn2_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->corn2; }
  ROS_DEPRECATED void set_corn2_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->corn2 = vec; }
  ROS_DEPRECATED uint32_t get_features_size() const { return (uint32_t)features.size(); }
  ROS_DEPRECATED void set_features_size(uint32_t size) { features.resize((size_t)size); }
  ROS_DEPRECATED void get_features_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->features; }
  ROS_DEPRECATED void set_features_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->features = vec; }
  ROS_DEPRECATED uint32_t get_descBuffer_size() const { return (uint32_t)descBuffer.size(); }
  ROS_DEPRECATED void set_descBuffer_size(uint32_t size) { descBuffer.resize((size_t)size); }
  ROS_DEPRECATED void get_descBuffer_vec(std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) const { vec = this->descBuffer; }
  ROS_DEPRECATED void set_descBuffer_vec(const std::vector<float, typename ContainerAllocator::template rebind<float>::other > & vec) { this->descBuffer = vec; }
  ROS_DEPRECATED uint32_t get_surfMatches_size() const { return (uint32_t)surfMatches.size(); }
  ROS_DEPRECATED void set_surfMatches_size(uint32_t size) { surfMatches.resize((size_t)size); }
  ROS_DEPRECATED void get_surfMatches_vec(std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other > & vec) const { vec = this->surfMatches; }
  ROS_DEPRECATED void set_surfMatches_vec(const std::vector<int32_t, typename ContainerAllocator::template rebind<int32_t>::other > & vec) { this->surfMatches = vec; }
private:
  static const char* __s_getDataType_() { return "ic2020_vodom/keyframe"; }
public:
  ROS_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROS_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "0ffd2f798c68a348fd55754d5e039856"; }
public:
  ROS_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROS_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "uint32 keyframe_num\n\
\n\
# Rotation and Translation\n\
float32[] rotation\n\
float32[] translation\n\
\n\
# Image\n\
uint32 height\n\
uint32 width\n\
uint8[] im\n\
\n\
# Depth Points\n\
uint32 numberOf3DPoints\n\
uint32 point_step #used for getting point in single row based off x and y coords\n\
uint8[] points\n\
\n\
# Shi Tomasi Corners\n\
uint32 numCorn1\n\
float32[] corn1 # relates this keyframe to last\n\
uint8[] status # which ones are good\n\
\n\
uint32 numCorn2\n\
float32[] corn2 # corners found in this keyframe to relate to next\n\
\n\
# SURF\n\
uint32 numSURF\n\
float32[] features\n\
float32[] descBuffer\n\
int32[] surfMatches # index of matches in previous keyframe, -1 means no match\n\
\n\
# IMU\n\
float32 imux\n\
float32 imuy\n\
float32 imuz\n\
\n\
"; }
public:
  ROS_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    ros::serialization::serialize(stream, keyframe_num);
    ros::serialization::serialize(stream, rotation);
    ros::serialization::serialize(stream, translation);
    ros::serialization::serialize(stream, height);
    ros::serialization::serialize(stream, width);
    ros::serialization::serialize(stream, im);
    ros::serialization::serialize(stream, numberOf3DPoints);
    ros::serialization::serialize(stream, point_step);
    ros::serialization::serialize(stream, points);
    ros::serialization::serialize(stream, numCorn1);
    ros::serialization::serialize(stream, corn1);
    ros::serialization::serialize(stream, status);
    ros::serialization::serialize(stream, numCorn2);
    ros::serialization::serialize(stream, corn2);
    ros::serialization::serialize(stream, numSURF);
    ros::serialization::serialize(stream, features);
    ros::serialization::serialize(stream, descBuffer);
    ros::serialization::serialize(stream, surfMatches);
    ros::serialization::serialize(stream, imux);
    ros::serialization::serialize(stream, imuy);
    ros::serialization::serialize(stream, imuz);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    ros::serialization::deserialize(stream, keyframe_num);
    ros::serialization::deserialize(stream, rotation);
    ros::serialization::deserialize(stream, translation);
    ros::serialization::deserialize(stream, height);
    ros::serialization::deserialize(stream, width);
    ros::serialization::deserialize(stream, im);
    ros::serialization::deserialize(stream, numberOf3DPoints);
    ros::serialization::deserialize(stream, point_step);
    ros::serialization::deserialize(stream, points);
    ros::serialization::deserialize(stream, numCorn1);
    ros::serialization::deserialize(stream, corn1);
    ros::serialization::deserialize(stream, status);
    ros::serialization::deserialize(stream, numCorn2);
    ros::serialization::deserialize(stream, corn2);
    ros::serialization::deserialize(stream, numSURF);
    ros::serialization::deserialize(stream, features);
    ros::serialization::deserialize(stream, descBuffer);
    ros::serialization::deserialize(stream, surfMatches);
    ros::serialization::deserialize(stream, imux);
    ros::serialization::deserialize(stream, imuy);
    ros::serialization::deserialize(stream, imuz);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    size += ros::serialization::serializationLength(keyframe_num);
    size += ros::serialization::serializationLength(rotation);
    size += ros::serialization::serializationLength(translation);
    size += ros::serialization::serializationLength(height);
    size += ros::serialization::serializationLength(width);
    size += ros::serialization::serializationLength(im);
    size += ros::serialization::serializationLength(numberOf3DPoints);
    size += ros::serialization::serializationLength(point_step);
    size += ros::serialization::serializationLength(points);
    size += ros::serialization::serializationLength(numCorn1);
    size += ros::serialization::serializationLength(corn1);
    size += ros::serialization::serializationLength(status);
    size += ros::serialization::serializationLength(numCorn2);
    size += ros::serialization::serializationLength(corn2);
    size += ros::serialization::serializationLength(numSURF);
    size += ros::serialization::serializationLength(features);
    size += ros::serialization::serializationLength(descBuffer);
    size += ros::serialization::serializationLength(surfMatches);
    size += ros::serialization::serializationLength(imux);
    size += ros::serialization::serializationLength(imuy);
    size += ros::serialization::serializationLength(imuz);
    return size;
  }

  typedef boost::shared_ptr< ::ic2020_vodom::keyframe_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ic2020_vodom::keyframe_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct keyframe
typedef  ::ic2020_vodom::keyframe_<std::allocator<void> > keyframe;

typedef boost::shared_ptr< ::ic2020_vodom::keyframe> keyframePtr;
typedef boost::shared_ptr< ::ic2020_vodom::keyframe const> keyframeConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::ic2020_vodom::keyframe_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::ic2020_vodom::keyframe_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace ic2020_vodom

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::ic2020_vodom::keyframe_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::ic2020_vodom::keyframe_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::ic2020_vodom::keyframe_<ContainerAllocator> > {
  static const char* value() 
  {
    return "0ffd2f798c68a348fd55754d5e039856";
  }

  static const char* value(const  ::ic2020_vodom::keyframe_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x0ffd2f798c68a348ULL;
  static const uint64_t static_value2 = 0xfd55754d5e039856ULL;
};

template<class ContainerAllocator>
struct DataType< ::ic2020_vodom::keyframe_<ContainerAllocator> > {
  static const char* value() 
  {
    return "ic2020_vodom/keyframe";
  }

  static const char* value(const  ::ic2020_vodom::keyframe_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::ic2020_vodom::keyframe_<ContainerAllocator> > {
  static const char* value() 
  {
    return "uint32 keyframe_num\n\
\n\
# Rotation and Translation\n\
float32[] rotation\n\
float32[] translation\n\
\n\
# Image\n\
uint32 height\n\
uint32 width\n\
uint8[] im\n\
\n\
# Depth Points\n\
uint32 numberOf3DPoints\n\
uint32 point_step #used for getting point in single row based off x and y coords\n\
uint8[] points\n\
\n\
# Shi Tomasi Corners\n\
uint32 numCorn1\n\
float32[] corn1 # relates this keyframe to last\n\
uint8[] status # which ones are good\n\
\n\
uint32 numCorn2\n\
float32[] corn2 # corners found in this keyframe to relate to next\n\
\n\
# SURF\n\
uint32 numSURF\n\
float32[] features\n\
float32[] descBuffer\n\
int32[] surfMatches # index of matches in previous keyframe, -1 means no match\n\
\n\
# IMU\n\
float32 imux\n\
float32 imuy\n\
float32 imuz\n\
\n\
";
  }

  static const char* value(const  ::ic2020_vodom::keyframe_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::ic2020_vodom::keyframe_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.keyframe_num);
    stream.next(m.rotation);
    stream.next(m.translation);
    stream.next(m.height);
    stream.next(m.width);
    stream.next(m.im);
    stream.next(m.numberOf3DPoints);
    stream.next(m.point_step);
    stream.next(m.points);
    stream.next(m.numCorn1);
    stream.next(m.corn1);
    stream.next(m.status);
    stream.next(m.numCorn2);
    stream.next(m.corn2);
    stream.next(m.numSURF);
    stream.next(m.features);
    stream.next(m.descBuffer);
    stream.next(m.surfMatches);
    stream.next(m.imux);
    stream.next(m.imuy);
    stream.next(m.imuz);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct keyframe_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ic2020_vodom::keyframe_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::ic2020_vodom::keyframe_<ContainerAllocator> & v) 
  {
    s << indent << "keyframe_num: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.keyframe_num);
    s << indent << "rotation[]" << std::endl;
    for (size_t i = 0; i < v.rotation.size(); ++i)
    {
      s << indent << "  rotation[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.rotation[i]);
    }
    s << indent << "translation[]" << std::endl;
    for (size_t i = 0; i < v.translation.size(); ++i)
    {
      s << indent << "  translation[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.translation[i]);
    }
    s << indent << "height: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.height);
    s << indent << "width: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.width);
    s << indent << "im[]" << std::endl;
    for (size_t i = 0; i < v.im.size(); ++i)
    {
      s << indent << "  im[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.im[i]);
    }
    s << indent << "numberOf3DPoints: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numberOf3DPoints);
    s << indent << "point_step: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.point_step);
    s << indent << "points[]" << std::endl;
    for (size_t i = 0; i < v.points.size(); ++i)
    {
      s << indent << "  points[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.points[i]);
    }
    s << indent << "numCorn1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numCorn1);
    s << indent << "corn1[]" << std::endl;
    for (size_t i = 0; i < v.corn1.size(); ++i)
    {
      s << indent << "  corn1[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.corn1[i]);
    }
    s << indent << "status[]" << std::endl;
    for (size_t i = 0; i < v.status.size(); ++i)
    {
      s << indent << "  status[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.status[i]);
    }
    s << indent << "numCorn2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numCorn2);
    s << indent << "corn2[]" << std::endl;
    for (size_t i = 0; i < v.corn2.size(); ++i)
    {
      s << indent << "  corn2[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.corn2[i]);
    }
    s << indent << "numSURF: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numSURF);
    s << indent << "features[]" << std::endl;
    for (size_t i = 0; i < v.features.size(); ++i)
    {
      s << indent << "  features[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.features[i]);
    }
    s << indent << "descBuffer[]" << std::endl;
    for (size_t i = 0; i < v.descBuffer.size(); ++i)
    {
      s << indent << "  descBuffer[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.descBuffer[i]);
    }
    s << indent << "surfMatches[]" << std::endl;
    for (size_t i = 0; i < v.surfMatches.size(); ++i)
    {
      s << indent << "  surfMatches[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.surfMatches[i]);
    }
    s << indent << "imux: ";
    Printer<float>::stream(s, indent + "  ", v.imux);
    s << indent << "imuy: ";
    Printer<float>::stream(s, indent + "  ", v.imuy);
    s << indent << "imuz: ";
    Printer<float>::stream(s, indent + "  ", v.imuz);
  }
};


} // namespace message_operations
} // namespace ros

#endif // IC2020_VODOM_MESSAGE_KEYFRAME_H

